% -*-cap2.tex-*-
% Este fichero es parte de la plantilla LaTeX para
% la realización de Proyectos Final de Carrera, protejido
% bajo los términos de la licencia GFDL.
% Para más información, la licencia completa viene incluida en el
% fichero fdl-1.3.tex

% Copyright (C) 2009 Pablo Recio Quijano 

En este capítulo se describen todos los aspectos relacionados con el diseño del sistema: arquitectura del sistema, patrones de diseño, diseño físico de datos, así como el diseño de la interfaz de usuario.

\section{Arquitectura física del sistema}

A continuación se presentan los elementos hardware que componen la arquitectura física del sistema. Para definirla, se detallarán los componentes a nivel de hardware requeridos para el correcto funcionamiento de la aplicación.\\

Cuando hablamos de un dispositivo móvil o smartphone, nos referimos a los sucesores de los teléfonos móviles sencillos, que han ido evolucionando hasta ser prácticamente ordenadores que caben en nuestros bolsillos o en nuestra palma de la mano, y que además incluyen las funciones básicas de sus antecesores, como pueden ser las llamadas, envío y recibo de sms, mms, etc.\\

En los últimos años los dispositivos móviles han empezado a cobrar importancia debido a su relación entre la potencia y su reducido tamaño, llegando incluso a ser indispensables en ciertos sectores de la sociedad hoy en día.\\

Junto con la aparición de los smartphones se presentaron a su vez los sistemas operativos que éstos dispositivos llevarían integrados como pueden ser Android o IOS, cada uno con características propias, ofreciendo así un entorno de fácil manejo para el usuario final y un sinfín de aplicaciones desarrolladas tanto por empresas como por particulares.\\

Dado que la presente aplicación ha sido desarrollada en Android, los requisitos a nivel de hardware se reducen a los siguientes:

\begin{itemize}
\item Dispositivos: Dispositivo móvil basado en Android.
\item Requisitos mínimos:
\begin{itemize}
\item La versión de Android instalada en el dispositivo debe ser superior o igual a la versión 4.0.3 (ICE\_CREAM\_SANDWICH\_MR1).
\item El dispositivo móvil debe disponer de Acelerómetro y Giroscopio.
\end{itemize}
\end{itemize}

Es conveniente destacar la necesidad de que el dispositivo móvil disponga de Acelerómetro y Giroscopio, dado que la combinación de estos dos sensores hardware son los que permiten que exista el sensor de Gravedad que, a diferencia de los dos sensores anteriormente citados, se trata de un sensor software.

\section{Arquitectura lógica del sistema}

En la arquitectura lógica del sistema se detallan los componentes a nivel de software empleados a lo largo del proyecto, que abarcan tanto al conjunto de aplicaciones, bibliotecas y librerías como al propio software desarrollado para cumplir con los objetivos y requisitos establecidos.

\subsection{Android}

\subsubsection{Introducción}

Android puede entenderse como una plataforma software cuya misión consiste en abstraer el hardware subyacente. Inicialmente fue desarrollado para dispositivos táctiles con recursos limitados, con el fin de facilitar el desarrollo de aplicaciones para dichos dispositivos.\\

La gran diferencia de Android respecto al resto de sistemas operativos para dispositivos móviles es su núcleo basado en GNU/Linux. Esto hace que Android adquiera algunas de las principales características de Linux, convirtiéndose en un software libre, gratuito y multiplataforma. \\

Inicialmente fue desarrollado por Android IC, pero en 2005 fue comprado por Google, y hasta entonces era un sistema operativo muy poco conocido. En el 2007 se fundó la Opend Handset Alliance, una agrupación de empresas de desarrollo de software, hardware y telecomunicaciones con el propósito de avanzar en los estándares abiertos para el desarrollo de software y hardware para dispositivos móviles, y fue entonces cuando se produjo la presentación de Android por parte de Google, liberando gran parte de su código bajo una licencia Apache.\\

El éxito tras la presentación fue escaso, debido a que el sistema operativo se presentó antes de que se comercializara ningún dispositivo que lo incluyese. En la actualidad es el sistema operativo más utilizado.

\subsubsection{Arquitectura}

La arquitectura del sistema Android puede verse como una arquitectura por capas o niveles, de forma que cada nivel puede utilizar servicios ofrecidos por los niveles anteriores y éste, a su vez, proporciona nuevas funciones a los niveles superiores. En la siguiente imagen podemos ver los niveles que componen la arquitectura:

\figura{arquitectura_android.png}{scale=0.9}{Arquitectura Android}{arquitectura_android}{H}

\begin{itemize}
\item \textbf{Aplicaciones:} Constituye el conjunto de aplicaciones presentes en un dispositivo, ya sean las instaladas por el usuario o por defecto, las nativas y las administradas.
\item \textbf{Framework de aplicaciones:} Plataforma de desarrollo que facilita la reutilización de componentes, permite el acceso a los diversos servicios ofrecidos y al hardware de los dispositivos. Los más importantes son:
\begin{itemize}
\item Activity Manager: Conjunto de APIs encargadas de gestionar el ciclo de vida de las aplicaciones.
\item Window Manager: Gestiona las ventanas de una aplicación mediante la librería Surface Manager.
\item Telephone Manager: Compendio de APIs que gestionan las funciones básicas de los teléfonos (llamadas, mensajería, etc).
\item Content Provider: Proporciona los mecanismos necesarios para la comunicación entre aplicaciones.
\item View System: Ofrece los elementos básicos necesarios para la construcción de interfaces.
\item Location Manager: Posibilita a las aplicaciones el acceso a la ubicación del dispositivo.
\item Notification Manager: Permite a las aplicaciones notificar al usuario información asociada a ciertos eventos que ocurran durante la ejecución de una aplicación.
\item XMPP Service: Colección de APIs para el uso de este protocolo de intercambio basado en XML.
\item Resource Manager: Encargado de gestionar todos los elementos que forman parte de una aplicación y son externos al código.
\item Package Manager: Gestor de todos los paquetes instalados en un dispositivo Android y que permite la instalación de nuevos paquetes.
\end{itemize}
\item \textbf{Bibliotecas:} Hacen referencia al conjunto de librerías presentes en Android y proporcionan la mayoría de las características más representativas de esta plataforma. Las principales librerías que podemos encontrar son las siguientes:
\begin{itemize}
\item Surface Manager: Gestión de la pantalla.
\item SQLite: Motor de bases de datos relacionales. Es el motor de bases de datos usado en la presente aplicación.
\item Media Framework: Reproducción de imágenes, vídeo y audio.
\item WebKit: Navegación web.
\item SGL: Gráficos 2D
\item Open GL/ES: Gráficos 3D.
\item FreeType: Renderizado de fuentes.
\item SSL: Comunicación segura mediante sockets.
\item Libcr: Variante optimizada de C.
\end{itemize}
\item \textbf{Android Runtime:} Al mismo nivel que las librerías encontramos el entorno de ejecución, que está constituido por las librerías Java que forman el núcleo del lenguaje y la máquina virtual Dalvik o ART para las versiones más modernas.
\item \textbf{Núcleo Linux:} Se utiliza como una capa de abstracción para el hardware subyacente y por tanto contiene los drivers y controladores necesarios para el correcto funcionamiento del mismo.
\end{itemize}

\subsubsection{Componentes de una aplicación Android}

Los componentes de una aplicación Android son los elementos esenciales que la componen. Cada uno de ellos supone un punto de entrada mediante el cual el sistema puede acceder a la aplicación, aunque no todos suponen puntos de entrada para el usuario.\\

Cada componente es un bloque básico que desempeña un papel específico en el funcionamiento de nuestra aplicación. Existen cuatro tipos diferentes de componentes, cada uno de ellos con un ciclo de vida y propósito único. Los componentes son los que siguen a continuación:

\begin{itemize}
\item \textbf{Actividades o Activities:} Cada actividad o activity respresenta una pantalla de nuestra aplicación. Las actividades trabajan en conjunto para dar una visión coherente de la aplicación, sin embargo, la vida de cada actividad es independiente del resto. El ciclo de vida que sigue una actividad se muestra en la siguiente imagen:
\figura{ciclo_vida_activity.png}{scale=0.9}{Arquitectura Android: Ciclo de vida de una Activity}{ciclo_vida_activity}{H}
\item \textbf{Servicios o Services:} Son componentes que se ejecutan en segundo plano con el fin de realizar operaciones de larga duración o procesos remotos. Los servicios carecen de interfaz y generalmente son llamados por las activities para realizar tareas costosas sin bloquear la interfaz, es decir, se pueden dejar en ejecución en segundo plano o logarlos a una actividad para interactuar con ella. En la siguiente imagen veremos el ciclo de vida de un servicio. En la izquierda está actuando en segundo plano y en la derecha está ligado a una activity:
\figura{ciclo_vida_servicio.png}{scale=0.9}{Arquitectura Android: Ciclo de vida de un Servicio}{ciclo_vida_servicio}{H}
\item \textbf{Proveedor de contenido o Content provider:} El proveedor de contenido gestiona los datos que maneja una aplicación. Controla el acceso a archivos, bases de datos SQLite, etc. Mediante el proveedor de contenidos las aplicaciones pueden consultar y modificar datos de otras aplicaciones siempre que posean los permisos adecuados. La siguiente imagen ilustra cómo una activity puede consultar datos de otra aplicación:
\figura{content_provider.png}{scale=0.9}{Arquitectura Android: Content Provider}{content_provider}{H}
\item \textbf{Receptor de difusiones o Broadcast receiver:} Es el componente encargado de responder a las difusiones o anuncios del sistema (por ejemplo, un anuncio del sistema que indica que queda poca batería). Carece de interfaz, pero debe crear una barra de estado para notificar al usuario cuando detexta una difusión. Una aplicación debe registrar un broadcast receiver para indicar qué difusiones le interesan.
\figura{broadcast_receiver.png}{scale=0.8}{Arquitectura Android: Broadcast Receiver}{broadcast_receiver}{H}
\end{itemize}

\subsubsection{Recursos de una aplicación Android}

Los recursos de una aplicación corresponden con todos los ficheros, imágenes, cadenas de texto, etc, que nuestra aplicación utiliza. Cuando trabajamos desarrollando aplicaciones para Android, las buenas prácticas nos dicen que este tipo de archivos debe mantenerse independientemente al código de la aplicación.\\

Este hecho, conocido como externalización de recursos, permite adaptar un mismo código a dispositivos con diferentes configuraciones y características físicas de una forma prácticamente automática. En la siguiente imagen podemos comprobar cómo quedaría una pantalla que no ha sido adaptada para diferentes dispositivos (parte superior) y una que sí (parte inferior):

\figura{externalizacion_recursos.png}{scale=0.9}{Arquitectura Android: Externalización de recursos}{externalizacion_recursos}{H}

\subsubsection{Manifest de una aplicación Android}

El archivo Manifest es un archivo XML que contiene información esencial para Android acerca de la aplicación. Todas las aplicaciones Android deben tener un archivo AndroidManifest.xml en su directorio raíz.\\

Entre todas las funciones que realiza el archivo manifest, las más significativas son las siguientes:

\begin{itemize}
\item Da nombre al paquete Java de la aplicación.
\item Describe los componentes y qué proceso los hospeda.
\item Contiene la declaración de permisos.
\item Lista las librería necesarias.
\item Declara el nivel mínimo de la API de Android requerido.
\end{itemize}

\subsection{Git}

Git es el software de control de versiones que se ha elegido para el desarrollo del proyecto. Fue desarrollado por Linus Torvalds (creador del sistema operativo Linux) y a día de hoy se usa en grandes proyectos, por ejemplo el propio núcleo de Linux. Como es costumbre en el desarrollo de éste proyecto, Git es software libre distribuido bajo la licencia GPL, lo que lo hace una alternativa libre de usar.\\

Git permite tener el código generado en la implementación del sistema en un repositorio (GitHub) y poder acceder a él remotamente desde cualquier PC, así como poder restaurar versiones anteriores en caso que la actual deba ser reemplazada.\\

Como para cualquier proyecto informático, el uso de un repositorio como GitHub para el alojamiento de la aplicación que nos ocupa se antojó necesario, no sólo por el simple hecho de tener todo el sistema alojado en la nube y disponible para cualquier persona, sino por la seguridad que transmite tener todo el desarrollo en un lugar desde donde sea posible descargarlo en cualquier PC y desarrollarlo en éste, por lo que pudiera suceder a lo largo del desarrollo del proyecto.

\subsection{SQLite}

La plataforma Android proporciona dos herramientas principales para el almacenamiento y consulta de datos estructurados, que ya hemos nombrado en los puntos anteriores:

\begin{itemize}
\item Bases de Datos SQLite.
\item Content providers.
\end{itemize}

En este punto nos centraremos en la primera opción, que es la que se usará en la aplicación implementada para el presente proyecto, y que abarcará todas las tareas relacionadas con el almacenamiento de los datos propios de nuestra aplicación.\\

SQLite es un sistema gestor de base de datos relacional (RDBMS) basado en el Lenguaje Estructurado de Consultas (SQL), tal y como sugiere su nombre. Lo que hace único a SQLite es que se considera una solución embebida. La mayoría de los sistemas de gestión de bases de datos como Oracle, MySQL y SQL Server son procesos de servidor autónomos que se ejecutan independientemente, mientras que SQLite es en realidad una librería que está enlazada dentro de las aplicaciones.\\

Se trata de un motor de bases de datos muy popular en la actualidad por ofrecer características tan interesantes como su pequeño tamaño, no necesitar servidor, precisar poca configuración, ser transaccional y por supuesto ser de código libre.\\

Android incorpora de serie todas las herramientas necesarias para la creación y gestión de bases de datos SQLite, y entre ellas una completa API para llevar a cabo de manera sencilla todas las tareas necesarias.\\

En Android, la forma típica de crear, actualizar y conectar con una base de datos SQLite será a través de una clase auxiliar llamada SQLiteOpenHelper, o para ser más exactos, de una clase propia que derive de ella y que debemos personalizar para adaptarnos a las necesidades concretas de nuestra aplicación.

\section{Patrones de diseño}

Los patrones de diseño se pueden definir como los esqueletos de las soluciones a problemas comunes en el desarrollo de software. Éstos brindan una solución ya probada y documentada a problemas de desarrollo de software que están sujetos a contextos similares.\\

Para que una solución sea considerada un patrón, debe poseer ciertas características. Una de ellas es que debe haber comprobado su efectividad resolviendo problemas similares en ocasiones anteriores. Otra es que debe ser reutilizable, lo que significa que es aplicable a diferentes problemas de diseño en distintas circunstancias.\\

Los patrones de diseño pretenden:

\begin{itemize}
\item Proporcionar catálogos de elementos reusables en el diseño de sistemas software.
\item Evitar la reiteración en la búsqueda de soluciones a problemas ya conocidos y solucionados anteriormente.
\item Formalizar un vocabulario común entre diseñadores.
\item Estandarizar el modo en que se realiza el diseño.
\item Facilitar el aprendizaje de las nuevas generaciones de diseñadores, condensando conocimientos ya existentes.
\end{itemize}

Asimismo, no pretenden:

\begin{itemize}
\item Imponer ciertas alternativas de diseño frente a otras.
\item Eliminar la creatividad inherente al proceso de diseño.
\end{itemize}

Para el presente proyecto se han usado patrones de diseño pertenecientes a diferentes subconjuntos de patrones de diseño. Éstos son el patrón Singleton, perteneciente al subconjunto de patrones de diseño creacionales, y el patrón Adapter, perteneciente al subconjunto de patrones de diseño estructurales. A continuación se detallarán ambos para dar conocimiento de cómo funcionan y cómo resuelven determinados problemas del sistema que los implementan.

\subsection{Patrones de diseño creacionales}

Corresponden a patrones de diseño de software que solucionan problemas de creación de instancias. Nos ayudan a encapsular y abstraer dicha creación.

\subsubsection{Patrón de diseño singleton}

El patrón singleton o patrón de instancia única es un patrón de diseño diseñado para restringir la creación de objetos pertenecientes a una clase o el valor de un tipo a un único objeto. Su intención consiste en garantizar que una clase sólo tenga una instancia y proporcionar un punto de acceso global a ella.\\

El patrón singleton se implementa creando en la clase un método que crea una instancia del objeto sólo si todavía no existe alguna. Para asegurar que la clase no puede ser instanciada nuevamente se regula el alcance del constructor haciéndo que éste sea privado y que sea a través de un método específico la manera de crear la primera y única instancia que se va a usar a lo largo del desarrollo.\\

En el desarrollo del presente proyecto, el uso de este patrón se usa para la clase que se ocupa de la definición de la base de datos, ya que a lo largo del proceso de ejecución del sistema sólo es necesario crear una única instancia de dicha clase.\\

\subsection{Patrones de diseño estructurales}

Corresponden a patrones de diseño de software que solucionan problemas de composición (agregación) de clases y objetos.

\subsubsection{Patrón de diseño adapter}

El patrón adapter, también conocido como wrapper, es un patrón de diseño que se utiliza para transformar una interfaz en otra, de tal modo que una clase que no pudiera utilizar otra clase cualquiera, haga uso de ella a través de una segunda. Dicho de otro modo, convierte la interfaz de una clase en otra interfaz que el cliente espera.\\

Este patrón de diseño permite a clases con interfaces incompatibles trabajar juntas mediante un adaptador intermedio, que se encargará de realizar la conversión de una interfaz a otra.\\

En el desarrollo de nuestra aplicación, el uso de este patrón se antoja necesario debido a los listados que se manejan en las diferentes pantallas de la aplicación, dado que, una vez que hemos obtenido de la base de datos el listado de usuarios, tests o sesiones, necesitaremos convertir dichas colecciones de objetos específicos en una colección de vistas (objeto View), que será sobre la que finalmente se iterará en la capa de presentación para pintar cada elemento en la layout correspondiente.

\section{Diseño físico de datos}

En este apartado se detalla el diseño físico de datos usado por nuestra aplicación.\\

Para que se cumplan con los objetivos y los requisitos impuestos en el proyecto, es necesario implementar una estructura capaz de almacenar la información, de forma que se pueda llevar un control y hacer un estudio de los datos obtenidos durante la realización de los tests que componen la batería de pruebas Senior Fitness Test.\\

La información almacenada en la base de datos consistirá tanto en las personas que realizarán los tests, como las sesiones que realizan y los resultados obtenidos en cada una de las pruebas completadas en dichas sesiones.

\subsection{Base de datos}

A continuación se detalla a través del diagrama Entidad-Relación cómo se estructura la base de datos SQLite diseñada para albergar la información citada en el punto anterior.

\figura{modeloconceptual_er_detail.png}{scale=0.9}{Diagrama Entidad-Relación de la base de datos}{ciclo_vida_servicio}{H}

Los atributos identificadores de cada tabla son enteros a excepción del identificador de persona, que se corresponde con el DNI de la misma. Las fechas de los campos date y birthdate son de tipo String pero parseadas desde tipo Date con el siguiente formato dd/MM/yyyy.\\

En el diagrama no se han representado como atributos de las entidades las claves foráneas, aunque sí aparecen en el fichero Contract de la aplicación, en el que se definen la base de datos y así mismo las tablas del proyecto.

\section{Diseño de la interfaz de usuario}

En este punto se especificarán los elementos que componen las distintas interfaces de usuario que existen para la aplicación, detallándose el contenido de cada pantalla representada.

\section{Uso del dispositivo móvil en la realización de ejercicios}

En este punto se especificará cómo debe usarse el dispositivo móvil en aquellos tests de la batería de pruebas Senior Fitness Test en los que podremos usar el dispositivo para que detecte el movimiento realizado durante los ejercicios, contabilizando de forma autónoma aquellas repeticiones que se realizan de forma satisfactoria.

\section{Diseño de clases UML}

En esta sección se va a mostrar el diseño empleado para el diagrama de clases UML del sistema, que mostrará el diseño de las clases que componen el sistema con sus atributos y métodos necesarios para cumplir con los requisitos y funcionalidades del proyecto expuestas en la etapa de análisis.\\

Dada la naturaleza de las aplicaciones Android, la mayor parte de las clases empleadas en el desarrollo de la aplicación serán activities, y cada una de ellas contendrá la lógica específica de una pantalla de la aplicación.\\

De entre todas las pantallas de la aplicación, hay seis que se corresponden con los tests o pruebas que componen la batería de pruebas Senior Fitness Test (una pantalla para cada test). Al tratarse de pantallas con una finalidad y objetivo similar, hay funcionalidades que comparten entre ellas, por lo que se ha optado por la creación de una activity padre llamada ExerciseActivity de la que extenderán las activities asociadas a cada uno de los tests: fuerza de brazos, fuerza de piernas, resistencia aeróbica, agilidad, flexibilidad de piernas y flexibilidad de brazos, simplificando de esta forma drásticamente el desarrollo de los tests que se vayan implementando sucesivamente tras el primero.\\

\section{Diseño de componentes}

Para el diseño de componentes se realizarán los diseños de los diagramas de secuencia que muestran el flujo de información existente entre el usuario y los componentes del sistema.

\subsection{Diagramas de secuencia}

Como es sabido de los diagramas de secuencia, éstos representan los flujos de comunicación que se dan para un determinado caso de uso del sistema, por lo que, dados los casos de uso desarrollados en el capítulo de análisis de requisitos para la aplicación que nos ocupa, se procederá a diseñarlos en base a estos diagramas.\\

Cabe destacar que no todos los posibles diagramas de secuencia aparecerán, sino que nos centraremos en aquellos casos de uso de la aplicación que se consideren mas relevantes.